# MP3流式音频播放测试指南

## 测试目标

验证新实现的MP3片段累积播放功能是否能正确处理后端流式推送的MP3音频片段。

---

## 核心改进

### 问题分析
- **原问题**：后端流式推送多个小的MP3片段（每个几百到几千字节）
- **失败原因**：浏览器Audio元素无法播放不完整的MP3片段
- **解决方案**：实现MP3片段累积策略，等待片段流推送完成后合并播放

### 实现机制

```typescript
// AudioPlayer核心逻辑
1. 收到MP3片段 → 累积到缓冲区
2. 启动300ms定时器
3. 300ms内无新片段 → 合并所有片段 → 添加到播放队列
4. 顺序播放队列中的音频
```

---

## 测试步骤

### 1. 启动开发服务器

```bash
npm run dev
```

### 2. 打开浏览器控制台

按 `F12` 打开开发者工具，切换到 Console 标签页。

### 3. 开始语音通话

点击"开始通话"按钮，观察控制台输出。

### 4. 说话触发AI回复

对着麦克风说话，等待AI回复。

---

## 关键日志监控

### 正常流程日志示例

```
# 1. 收到第一个MP3片段
收到音频数据，大小: 836 bytes
音频数据前两个字节: 0xFF 0xF3
AudioPlayer.play 被调用，数据大小: 836 bytes
累积MP3片段，当前缓冲区片段数: 1

# 2. 收到更多MP3片段
收到音频数据，大小: 2926 bytes
音频数据前两个字节: 0xFF 0xF3
AudioPlayer.play 被调用，数据大小: 2926 bytes
累积MP3片段，当前缓冲区片段数: 2

# 3. 300ms后无新片段，开始合并
合并MP3片段，共 2 个片段
合并后总大小: 3762 bytes
创建合并后的Blob，大小: 3762 bytes
添加到播放队列，当前队列长度: 1

# 4. 开始播放
开始播放Blob，大小: 3762 bytes
音频播放结束，释放资源
Blob播放完成
```

### 成功标志

✅ **片段累积正常**
- 看到 "累积MP3片段，当前缓冲区片段数: X"
- 片段数逐渐增加（1, 2, 3...）

✅ **合并时机正确**
- 看到 "合并MP3片段，共 X 个片段"
- 300ms内无新片段后才触发合并

✅ **播放成功**
- 看到 "音频播放结束，释放资源"
- 没有 "NotSupportedError" 错误

✅ **队列管理正常**
- "当前队列长度" 应该保持在较低水平（1-2）
- 不应该出现长时间积压（队列长度 > 5）

### 失败标志

❌ **仍然无法播放**
- 看到 "播放MP3音频失败: NotSupportedError"
- 说明合并后的音频仍不完整

❌ **队列积压严重**
- "当前队列长度" 持续增长到很大（> 10）
- 说明播放速度跟不上接收速度

❌ **片段格式错误**
- 看到 "收到的数据可能不是有效的MP3格式"
- 前两字节不是 0xFF 0xFB 或 0xFF 0xF3

---

## 性能调优参数

### 调整合并等待时间

如果需要调整片段累积的等待时间，修改 `src/services/audioPlayer.ts`：

```typescript
private readonly CHUNK_WAIT_MS = 300 // 默认300ms
```

- **增大（如500ms）**：适用于后端推送间隔较大的场景
- **减小（如100ms）**：适用于需要更快响应的场景

---

## 常见问题排查

### Q1: 音频仍然无法播放

**可能原因**：
1. 后端发送的MP3片段本身不完整（缺少文件头或元数据）
2. 合并逻辑有问题

**排查步骤**：
1. 检查控制台 "合并后总大小" 是否合理（应该至少几KB）
2. 检查是否有 Audio元素错误信息
3. 尝试将合并后的Blob保存为文件，用播放器验证

**临时方案**：
联系后端确认TTS服务是否应该发送完整可播放的MP3文件，而非流式片段。

### Q2: 队列积压严重

**可能原因**：
1. 播放速度 < 接收速度
2. 每个合并的音频块播放失败导致队列堆积

**排查步骤**：
1. 检查是否有播放失败的错误
2. 观察 "Blob播放完成" 日志是否正常出现

**解决方案**：
- 如果播放失败：参考 Q1
- 如果播放正常但太慢：可能需要优化播放策略

### Q3: 合并时机不对

**现象**：片段还在持续到达时就开始合并

**排查步骤**：
1. 检查片段到达间隔是否 > 300ms
2. 观察 "累积MP3片段，当前缓冲区片段数" 的变化

**解决方案**：
适当增大 `CHUNK_WAIT_MS` 参数。

---

## 高级测试

### 手动触发合并

在浏览器控制台执行：

```javascript
// 假设你能访问到 voiceCallManager 实例
voiceCallManager.audioPlayer.forceFlush()
```

这会立即触发缓冲区合并，无需等待定时器。

### 查看音频数据

```javascript
// 在 AudioPlayer.playBlob 方法中添加
const reader = new FileReader()
reader.onload = () => {
  console.log('Blob数据（base64）:', reader.result)
}
reader.readAsDataURL(blob)
```

可以将base64数据复制到在线MP3播放器验证。

---

## 预期结果

### 成功标准

1. ✅ 音频能够正常播放（听到AI语音）
2. ✅ 控制台没有 "NotSupportedError" 错误
3. ✅ 播放队列长度保持在合理范围（1-3）
4. ✅ 看到完整的片段累积→合并→播放流程日志

### 如果仍然失败

需要与后端确认以下问题：

1. **TTS服务输出格式**：是否为完整的MP3文件还是流式片段？
2. **MP3编码参数**：比特率、采样率、声道数
3. **分片策略**：是按时间分片还是按大小分片？
4. **是否包含完整的MP3头**：每个片段是否都有完整的ID3标签和帧头？

可能需要后端调整为：
- 发送完整的MP3文件（不分片）
- 或使用支持流式播放的格式（如使用MediaSource API）

---

## 下一步优化方向

如果当前方案仍有问题，可以考虑：

1. **使用MediaSource API**：支持真正的流式MP3播放
2. **使用Web Audio API**：更底层的音频处理
3. **要求后端改为PCM格式**：客户端自行编码和播放
4. **使用第三方库**：如howler.js处理音频播放

---

## 联系支持

如果问题持续存在，请提供以下信息：

1. 完整的控制台日志
2. 浏览器版本和操作系统
3. 后端TTS服务的配置信息
4. 一个示例MP3片段的数据（可导出为文件）
